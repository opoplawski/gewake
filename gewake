#!/usr/bin/perl -w
#
# gewake - monitor grid engine and wake up hosts if needed
#
# Copyright (C) 2012 Orion Poplawski <orion@cora.nwra.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

use Getopt::Std;
use Date::Manip;

# Convert units into raw sizes
sub memValue {
   my ($arg) = @_;

   $arg =~ s/([KMG])//;
   return $arg if !defined($1);
   if ($1 eq "K") {
      $arg *= 1024;
   } elsif ($1 eq "M") {
      $arg *= 1024*1024;
   } elsif ($1 eq "G") {
      $arg *= 1024*1024*1024;
   }
   return $arg;
}

# Load a parallel environment
sub loadParallelEnv {
   my ($envname) = @_;
   my %envconf;

   open(ENV,"qconf -sp $envname |");
   while (<ENV>) {
      chomp;
      my ($key,$value) = split(/ +/, $_);
      $envconf{$key} = $value;
   }
   close(ENV);

   return \%envconf;
}

sub loadParallelEnvs {
   my ($envname) = @_;
   my %envconf;

   if ($envname =~ /\*/) {
      $envregex = $envname;
      $envregex =~ s/\*/.*/;
      open(ENVS,"qconf -spl |");
      while (<ENVS>) {
         chomp;
         if (/$envregex/) {
            $envconf{$envname} = loadParallelEnv($_);
         }
      }
      close(ENVS);
   } else {
      $envconf{$envname} = loadParallelEnv($envname);
   }

   return \%envconf;
}

my $version = "1.3";
my $wakehostsfile = "/usr/local/etc/gewake.hosts";
my $wakeupcmd = "/usr/local/bin/wakeup";
my %status = ();
my $usage = <<EOU;
Usage: gewake [-d]

 -d Turns on debugging output
EOU

getopts("d",\%opts) || die $usage;

#These are the hosts we wake up, put in order of preference
open(HOSTS,"< $wakehostsfile") or die "Cannot open $wakehostsfile";
while (<HOSTS>) {
   chomp;
   s/#.*//;
   push(@wakeupHosts,$_) if $_;
}
close(HOSTS);

# See if there are any waiting jobs
#job-ID  prior   name       user         state submit/start at     queue                 slots ja-task-ID

open(QSTAT,'qstat -u \* |');
my $now = new Date::Manip::Date("now");
my %jobinfo;
while (<QSTAT>) {
   chomp;
   my ($jobid,$prior,$name,$user,$state,$submitdate,$submittime,$slots,$tasklist) = split;
   if (defined($state) && $state =~ /q/ && $state !~ /E/) {
      # Determine how many seconds ago the job was submitted
      my $subdate = new Date::Manip::Date("$submitdate $submittime");
      my $seconds = $now->calc($subdate, 1)->printf('%sys');

      # Wait for 60 seconds for scheduler to process new jobs
      if ($seconds > 60 or defined($opts{'d'})) {
         push(@waiting,$jobid);

         #Track some other info
         my $numtasks = 0;
         print "$jobid slots=$slots, tasklist=$tasklist" if (defined($opts{'d'}));
         if (defined($tasklist) and $tasklist ne "") {
            $jobinfo{$jobid}->{"tasklist"} = $tasklist;
            foreach $taskentry (split(",",$tasklist)) {
               my ($starttask,$endtask,$stride);
               if (($starttask,$endtask,$stride) = ($taskentry =~ /(\d+)-(\d+):(\d+)/)) {
                  $numtasks += ($endtask-$starttask+1)/$stride;
               } elsif ($taskentry =~ /^\d+$/) {
                  $numtasks++;
               }
            }
         } else {
            $numtasks = 1;
         }
         print "($numtasks)\n" if (defined($opts{'d'}));
         $jobinfo{$jobid}->{"slots"} = $slots * $numtasks;
         $jobinfo{$jobid}->{"user"} = $user;
      }
   }
}
close(QSTAT);

# Open status files
# Last host we tried to wake up
$lastwake = "";
if (-f "/var/lib/gewake/last") {
  chomp($lastwake = `cat /var/lib/gewake/last`);
  # clear the last woken up hosts status file
  unlink("/var/lib/gewake/last");
}

# Quit if no waiting jobs
exit unless @waiting;

# List of hosts to not wake up
@blacklist = ();
if (-f "/var/lib/gewake/blacklist") {
  open(BL,"< /var/lib/gewake/blacklist");
  while (<BL>) {
    chomp;
    push(@blacklist,$_);
  }
  close(BL);
}

# Debug
if (defined($opts{'d'}) and @waiting) {
  print "Waiting: " . join(",",@waiting) . "\n";
}

# Collect queue information
#queuename                      qtype used/tot. load_avg arch          states
open(QSTAT,'qstat -f -F|');
my ($queue,$host);
while (<QSTAT>) {
   chomp;
   if (/@/) {
      my ($queueent,$qtype,$slots,$loadave,$arch,$state) = split;
      # Strip domain
      $queueent =~ s/\.[^@]*$//;
      ($queue,$host) = split("@",$queueent);

      # Debug
      print "$_ -> ($queue,$host)\n" if (defined($opts{'d'}));

      # Add to list of queues unless it is disabled
      push(@{$queuesForHost{$host}},$queue) unless $state =~ /d/;

      # Record default status for queues that are up.  We don't set
      # the status for down ones because we may override them later
      if ($state !~ "u") {
         $status{$queueent} = "up";
      }
      if ($state =~ "d") {
         $status{$queueent} = "disabled";
      }
      if ($state =~ "S") {
         $status{$queueent} = "suspended";
      }

      # Record number of slots in the queue entry
      $qhresource{$queueent}->{"slots"} = $slots;

      # Record queue type
      $queuetype{$queue} = $qtype
   } elsif (my ($type,$resource,$value) = /(\w\w):(\S+)=(\S+)/) {
      # Parse the resources for the queue
      print STDERR "Cannot parse $_ for resources\n" unless defined($resource);
      if ($resource =~ /^mem_/) { $value = &memValue($value); }
      $qhresource{"$queue\@$host"}->{$resource} = $value;
   }
}
close(QSTAT);

# Get information on complexes
# qconf -sc
#  #name               shortcut    type        relop requestable consumable default  urgency 
#  #-----------------------------------------------------------------------------------------
#  arch                a           RESTRING    ==    YES         NO         NONE     0
my (%complex);
open(QCONF,'qconf -sc |') or die 'Cannot run qconf -sc';
while (<QCONF>) {
   next if /^#/;
   chomp;
   my ($name,$shortcut,$type,$relop,$req,$con,$default,$urgency) = split(" ");
   # Only need requestable ones
   if ($req eq "YES" or $req eq "FORCED") {
      $complex{$name}->{"type"} = $type;
      # Modify operator for string comparisons
      if ($type eq "RESTRING") { $relop = "eq" };
      $complex{$name}->{"relop"} = $relop;
      print "complex: $name $type $relop\n" if defined($opts{'d'});
   }
}

# See why the jobs are waiting
# qstat -j output:
#hard_queue_list:   compute.q
#scheduling info:   queue instance "queue@hostname"
#                   queue instance "queue@hostname" dropped because it is temporarily not available
#                   queue instance "queue@hostname" dropped because it is full
#                   queue instance "queue@hostname" dropped because it is disabled
#                   cannot run in queue "queue" because it is not contained in its hard queue list (-q)
my @wokenhosts = ();
my $slotsneeded = 0;
JOB: foreach $jobid (@waiting) {
   print("Processing $jobid(slots=$jobinfo{$jobid}->{slots})\n") if (defined($opts{'d'}));
   my $schedinfo = 0;
   my $hardqueuelist = "";
   my $error = 0;
   my %hardresource = ();
   my $parallelenvconf = undef;
   my $parallelenv = "";
   my $parallelrange = "";
   my $parallelalloc = "";
   my ($perangemin,$perangemax);
   my $woke = 0;
   open(QSTAT,"qstat -j $jobid |");
   while (<QSTAT>) {
      chomp;
      # Job is in error state
      $error = 1 if /^error reason/;

      # Get the hard resources to see if we can avoid waking up machines that
      # don't satisfy them
      if (/^hard resource_list:\s+(\S+)/) {
         foreach $item (split(",",$1)) {
            my ($resource,$value) = split("=",$item);
            if ($resource =~ /^mem_/) { $value = &memValue($value); }
            $hardresource{$resource} = $value;
         }
      }

      # Signal start of scheduling info parsing
      $schedinfo = 1 if s/^scheduling info://;

      if (!$schedinfo) {
         if (/^hard_queue_list:\s*(.*)/) {
            # Record the hard queue list request
            $hardqueuelist = $1;
            # Strip domain
            $hardqueuelist =~ s/(@\w+)\.[\w.]+/$1/g if ($hardqueuelist =~ /@/);
         } elsif (/^parallel environment:\s*(.*) range:\s*(.*)/) {
            $parallelenv = $1;
            $parallelrange = $2;
            ($perangemin,$perangemax) = ($parallelrange =~ /(\d+)-?(\d+)?/);
            $parallelenvconf = loadParallelEnvs($parallelenv) if !defined($parallelenvconf->{$parallelenv});
            foreach $penv (keys(%$parallelenvconf)) {
               $parallelalloc = $parallelenvconf->{$penv}->{"allocation_rule"};
            }
            $jobinfo{$jobid}->{"slots"} = $perangemin;
            print STDERR "Setting slots to $jobinfo{$jobid}->{slots} for parallelenv $parallelenv job\n" if (defined($opts{'d'}));
         }
         next;
      } else {
         my $junk;
         if (($queue,$status) = /queue instance "(.+)" (?:dropped |)because it is (.+)/) {
            # Strip domain
            $queue =~ s/\.[^@]*$//;

            # Set the status if it isn't already "up"
            $status{$queue} = $status; # unless defined($status{$queue});

            # Debug
            print "status{$queue} = $status\n" if (defined($opts{'d'}));
         } elsif (($queue,$status) = /queue instance "(.+)" is in (.+)/) {
            # Strip domain
            $queue =~ s/\.[^@]*$//;

            # Set the status if it isn't already "up"
            $status{$queue} = $status unless defined($status{$queue});

            # Debug
            print "status{$queue} = $status\n" if (defined($opts{'d'}));
         } elsif (($queue) = /has no permission for cluster queue "(.+)"/) {
            # Strip domain
            $queue =~ s/\.[^@]*$//;

            # Set the status if it isn't already "up"
            $status{$queue} = "noaccess" unless defined($status{$queue});

            # Debug
            print "status{$queue} = $status{$queue}\n" if (defined($opts{'d'}));
         } else {
            # We don't think we care about anything else, but list it if debugging
            print "Unknown status line: $_\n" if (defined($opts{'d'}));
         }
      }
   }
   close(QSTAT);

   # Don't process error state jobs
   next if $error;

   $slotsneeded += $jobinfo{$jobid}->{slots};
   next JOB if $slotsneeded < 0;

   # For specific host requests
   if ($hardqueuelist) {
      # Debug
      print("$jobid hardqueuelist=$hardqueuelist\n") if (defined($opts{'d'}));

      QUEUEENTRY: foreach $hardqueueentry (split(",",$hardqueuelist)) {
         if ($hardqueueentry !~ /@/) {
            # If only requesting a queue, find all hosts in that queue
            @hardqueuehosts = grep($_ =~ /^$hardqueueentry@/,keys(%status));
         } else {
            @hardqueuehosts = ($hardqueueentry);
         }
         print "$jobid hardquehosts=" . join(",",@hardqueuehosts) . "\n" if defined($opts{'d'});
         # Wakeup hosts in wakeupHosts order
         QUEUEHOST: foreach my $hardqueuehost (map { my $b = $_; grep { $_ =~ /\@$b$/ } @hardqueuehosts } @wakeupHosts) {
            my ($queue,$host) = ($hardqueuehost =~ /(.+)@(.+)/);
            # Debug
            print("$jobid hardqueuehost=$hardqueuehost status=$status{$hardqueuehost}\n") if (defined($opts{'d'}));

            # Skip queue if it is the wrong type
            if ($parallelenv eq "" and $queuetype{$queue} !~ /B/) {
               print("$jobid Skipping $hardqueuehost because it is not of type batch\n");
               next QUEUEHOST
            }
            if ($parallelenv ne "" and $queuetype{$queue} !~ /P/) {
               print("$jobid Skipping $hardqueuehost because it is not of type parallel\n");
               next QUEUEHOST
            }

            # Wake it up if unavailable, we haven't already done so, and it's in the list of hosts to wake up
            if (defined($status{$hardqueuehost}) &&
                $status{"$hardqueuehost"} eq "temporarily not available" &&
                !grep($_ eq $host,@wokenhosts) && grep($_ eq $host,@wakeupHosts) &&
                $host ne $lastwake) {
               # Handle parallel environment requests
               if ($parallelenv ne "") {
                  if ($parallelalloc eq '$pe_slots') {
                     if ($perangemin > $qhresource{$hardqueuehost}->{"slots"}) {
                        print STDERR "Skipping $host because parallel env $parallelenv needs $perangemin slots > " . $qhresource{$hardqueuehost}->{"slots"} . "\n" if (defined($opts{'d'}));
                        next QUEUEHOST;
                     }
                  }
               }

               print("Waking up $host for $hardqueueentry, slots = ". $qhresource{$hardqueuehost}->{"slots"} . ", status=$status{$hardqueuehost}, slots needed = $slotsneeded\n") if ($jobinfo{$jobid}->{"user"} ne "root" or defined($opts{'d'}));
               system("$wakeupcmd $host") unless defined($opts{'d'});
               $woke++;
               push(@wokenhosts,$host);

               # Record that last host woken up
               open(LAST,"> /var/lib/gewake/last") or die;
               print LAST "$host\n";
               close(LAST);

               # See if we need more slots
               $slotsneeded -= $qhresource{$hardqueuehost}->{"slots"};
               print("slots needed = $slotsneeded\n") if (defined($opts{'d'}));

               # If we still need more slots, sleep a bit to stagger power ups
               # then try another host
               if ($slotsneeded > 0) {
                  sleep(15);
                  next QUEUEHOST;
               } else {
                  next JOB;
               }

               # Sleep a bit to stagger power ups
               sleep(15);
               ## Quit to let the host(s) come up and jobs get scheduled to it
               #exit(0);
            } else {
               # Try the next entry in the hardquelist
               next QUEUEHOST;
            }
         }
      }

      # Go to the next job
      next JOB;
   }

   # Go through the list of wakeupHosts in order and wake up if needed
   HOST: foreach $host (@wakeupHosts) {
      # We may not have any queues because they may be disabled
      next if !defined($queuesForHost{$host});

      # Skip if we've already tried to wake it up
      next if grep($_ eq $host,@wokenhosts);

      # regexp for all of the queues we have access to
      my $queuematch = join("|",grep {!defined($status{$_}) or $status{$_} ne "noaccess"} @{$queuesForHost{$host}});

      # Loop through the queues
      QUEUE: foreach my $queue (@{$queuesForHost{$host}}) {
      #print STDERR "No queue for host $host\n" if !defined($queue);

         # Debug
         print "host=$host queuematch=$queuematch $queue status{${queue}\@${host}}=" . $status{"$queue\@$host"} . "\n" if (defined($opts{'d'}));

         # Skip queue if it is the wrong type
         next QUEUE if $parallelenv eq "" and $queuetype{$queue} !~ /B/;
         next QUEUE if $parallelenv ne "" and $queuetype{$queue} !~ /P/;

         # Wakeup if we don't have a hard queue list or it's in our hard queue list,
         # and the host is down
         if (($hardqueuelist eq "" || $hardqueuelist =~ /($queuematch)/) &&
             defined($status{"$queue\@$host"}) &&
             $status{"$queue\@$host"} eq "temporarily not available") {
            if (grep(/^$host$/,@blacklist)) {
               #Blacklisted, skip
               print STDERR "Skipping blacklisted host $host\n" if (defined($opts{'d'}));
               next HOST;
            } elsif ($host eq $lastwake) {
               print("Giving up on $host, trying the next one.\n");
   # This isn't working well right now, but the idea is to give up on failing hosts
   #            open(BL,">> /var/lib/gewake/blacklist");
   #            print BL "$host\n";
   #            close(BL);
               next HOST;
            } else {
               # Check hard resources using the appropriate complex method
               foreach $resource (sort(keys(%hardresource))) {
                  print STDERR "Checking resource requirement $resource: " if (defined($opts{'d'}));
                  if (defined($qhresource{"$queue\@$host"}->{$resource})) {
                     my $thishardresource = $hardresource{$resource};
                     # Booleans are reported as numeric, but can be specified as true/false
                     $thishardresource =~ s/true/1.000000/;
                     print STDERR "next HOST if !($thishardresource" . (($complex{$resource}->{'type'} eq "MEMORY") ? " * $jobinfo{$jobid}->{slots}" : "") . ") $complex{$resource}->{relop} " . $qhresource{"$queue\@$host"}->{$resource} . ")\n" if (defined($opts{'d'}));
                     if ($complex{$resource}->{'relop'} eq "eq") {
                        # Need to quote strings
                        next HOST if eval "!(\"$thishardresource\" $complex{$resource}->{'relop'} \"$qhresource{\"$queue\@$host\"}->{$resource}\") ";
                     } else {
                        next HOST if eval "!(($thishardresource" . (($complex{$resource}->{'type'} eq "MEMORY") ? " * $jobinfo{$jobid}->{slots}" : "") . ") $complex{$resource}->{'relop'} $qhresource{\"$queue\@$host\"}->{$resource})";
                     }
                  } else {
                     next HOST;
                  }
               }

               # Handle parallel environment requests
               if ($parallelenv ne "") {
                  if ($parallelalloc eq '$pe_slots') {
                     if ($perangemin > $qhresource{"$queue\@$host"}->{"slots"}) {
                        print STDERR "Skipping $host because parallel env $parallelenv needs $perangemin slots > " . $qhresource{"$queue\@$host"}->{"slots"} . "\n" if (defined($opts{'d'}));
                        next HOST;
                     }
                  }
               }

               print("Waking up $host for queue $queue, slots = ". $qhresource{"$queue\@$host"}->{"slots"} . ", status = " . $status{"$queue\@$host"} . ", slots needed = $slotsneeded\n") unless $jobinfo{$jobid}->{"user"} eq "root";
               system("$wakeupcmd $host") unless defined($opts{'d'});
               $woke++;
               push(@wokenhosts,$host);

               # Record that last host woken up
               open(LAST,"> /var/lib/gewake/last") or die;
               print LAST "$host\n";
               close(LAST);

               # Redeuce the slots needed by the slots provided by this host
               $slotsneeded -= $qhresource{"$queue\@$host"}->{"slots"};
               print("slots needed = $slotsneeded\n") if (defined($opts{'d'}));

               # If we still need more slots, sleep a bit to stagger power ups
               # then try another host
               if ($slotsneeded > 0) {
                  sleep(15);
                  next HOST;
               } else {
                  next JOB;
               }

               # Quit to let the host(s) come up and jobs get scheduled to it
               exit(0);
            }
#         } elsif ($status{"$queue\@$host"} eq "up") {
#               # Redeuce the slots needed by the slots provided by this host
#               print("Reducing needs slots by " . $qhresource{"$queue\@$host"}->{"slots"} . " for up host $host\n") if (defined($opts{'d'}));
#               $jobinfo{$jobid}->{"slots"} -= $qhresource{"$queue\@$host"}->{"slots"};
#               print("slots left = " . $jobinfo{$jobid}->{"slots"} . "\n") if (defined($opts{'d'}));
         }

         if ($jobinfo{$jobid}->{"slots"} <= 0) {
            print("Giving up on job $jobid, no more slots needed\n") if (defined($opts{'d'}));
            next JOB;
         }
      }
   }
}
